
Filename: csvls/src/cli/ArgumentHandler.cpp
Contents:
// ArgumentHandler.cpp
// An implementation of ArgumentHandler.hpp
#include <string>
#include <string_view>
#include <forward_list>
#include <tuple>
#include <stdexcept>
#include <format>
#include <ranges>
#include "ArgumentHandler.hpp"

void ArgumentHandler::init_raw_arguments_(int &argc, char **&argv) {
    for (size_t i = 1; i < argc; ++i) { // skip argv[0]
        raw_arguments_.emplace_front(argv[i]);
    }

	// check whether targets are present or not

    if (!check_raw_arguments_(raw_arguments_)) {
        throw std::invalid_argument("No mandatory arguments specified, try -h(--help)");
    }
}


bool ArgumentHandler::check_raw_arguments_(raw_arguments& raw_arguments) {
	return 
	std::any_of(
		raw_arguments.begin(),
		raw_arguments.end(),
		[](const std::string_view &a){return a.starts_with('-');}
	) && std::any_of(
		raw_arguments.begin(),
		raw_arguments.end(),
		[](const std::string_view &a){return !a.starts_with('-');}
	);
}

ArgumentHandler::ArgumentHandler(int &argc, char **&argv) {
	init_raw_arguments_(argc, argv);
}

parsed_pair ArgumentHandler::parse_all_(raw_arguments& raw_arguments)
{
	for (std::string_view& arg : raw_arguments)
	{
		// btw this is not me commenting on the code cuz its unreadable
		// its more readable that python ong

		// If an argument starts with "-" or "--", then
		// it is an option, thus send it to respective method
		// and emplace it to respective list
        if (arg.starts_with("-")) {
			parse_option_(arg);
        }
		// Else, it’s a target (positional argument)
		else {
			parse_target_(arg);
		}
    }


	return {parsed_options_, parsed_targets_};
}

void ArgumentHandler::parse_option_(std::string_view& arg) {
	// pretty straightforward no expl needed
	size_t dashes = arg.find_first_not_of('-');
	arg.remove_prefix(dashes);
	if (dashes == 2) {
		parsed_options_.emplace_back(deduce_full_option_(arg));
	}
	else if (dashes == 1) {
		for (const char c : arg) {
			parsed_options_.emplace_back(deduce_option_(c));
		}
	}
	else {
		throw std::invalid_argument(std::format("Option {} not found\n", arg));
	}
}

void ArgumentHandler::parse_target_(const std::string_view& arg) {
	parsed_targets_.emplace(arg);
}

parsed_pair ArgumentHandler::get_parsed() {
	return parse_all_(raw_arguments_);
}

Option ArgumentHandler::deduce_full_option_(const std::string_view& arg) {
    if (arg == "help") return Option::Help;
    else if (arg == "show-dev") 			return Option::ShowDev;
    else if (arg == "show-inode") 			return Option::ShowInode;
    else if (arg == "show-type") 			return Option::ShowType;
    else if (arg == "show-perms") 			return Option::ShowPerms;
    else if (arg == "show-nlinks") 			return Option::ShowNLinks;
    else if (arg == "show-owner") 			return Option::ShowOwner;
    else if (arg == "show-group") 			return Option::ShowGroup;
    else if (arg == "show-size") 			return Option::ShowSize;
    else if (arg == "show-blocks") 			return Option::ShowBlocks;
    else if (arg == "show-access-time") 	return Option::ShowAccessTime;
    else if (arg == "show-mod-time") 		return Option::ShowModTime;
    else if (arg == "show-meta-mod-time") 	return Option::ShowMetaModTime;
    else if (arg == "name") 				return Option::Name;
    else if (arg == "canonical") 			return Option::Canonical;
    else if (arg == "sort") 				return Option::Sort;
    else if (arg == "rec") 					return Option::Recurcive;
    else 									throw_invalid_argument_(arg);
}

Option ArgumentHandler::deduce_option_(const char c) {
    switch (c) {
    case 'h': return Option::Help;
    case 'd': return Option::ShowDev;
    case 'I': return Option::ShowInode;
    case 't': return Option::ShowType;
    case 'p': return Option::ShowPerms;
    case 'n': return Option::ShowNLinks;
    case 'O': return Option::ShowOwner;
    case 'g': return Option::ShowGroup;
    case 's': return Option::ShowSize;
    case 'b': return Option::ShowBlocks;
    case 'a': return Option::ShowAccessTime;
    case 'm': return Option::ShowModTime;
    case 'M': return Option::ShowMetaModTime;
    case 'N': return Option::Name;
    case 'c': return Option::Canonical;
    case 'S': return Option::Sort;
    case 'r': return Option::Recurcive;
    default: throw_invalid_argument_(c); break;
    }
}




Filename: csvls/src/cli/test.cpp
Contents:
//a test
#include <iostream>
#include <sstream>
#include "ArgumentHandler.hpp"
#include "Option.hpp"

std::ostream& operator<<(std::ostream& o, parsed_options& a) {
	for (const Option& arg : a) {
		o << static_cast<int>(arg) << ' ';
	}
	o << '\n';
	return o;
}

std::ostream &operator<<(std::ostream &o, parsed_targets &a) {
    for (const std::string &arg : a) {
        o << arg << ' ';
    }
    o << '\n';
    return o;
}

int main(int argc, char **argv) try {
	ArgumentHandler handler(argc, argv);
	parsed_pair parsed = handler.get_parsed();




    std::cout << "parsed options: "<< parsed.first;
	std::cout << "parsed targers: "<< parsed.second;
}
catch (std::invalid_argument& exception) {
	std::cout << "Invalid argument: " << exception.what() << '\n';
}



Filename: csvls/src/aliases_and_concepts/using.hpp
Contents:
#ifndef USING_H
#define USING_H

#include <unordered_set>
#include <forward_list>


using raw_arguments = std::forward_list<std::string_view>;
using parsed_options = OrderedUnique<Option>;
using parsed_targets = std::unordered_set<std::string>;
using parsed_pair = std::pair<parsed_options, parsed_targets>;

#endif



Filename: csvls/src/aliases_and_concepts/concept.hpp
Contents:
#ifndef CONCEPT_H
#define CONCEPT_H

#include <string>
#include <string_view>

template <typename T>
concept CharOrString =
    std::same_as<T, char> ||
    std::same_as<T, std::string> ||
    std::same_as<T, std::string_view>;

template<typename O>
concept Enum = std::is_enum_v<O>;

#endif



Filename: csvls/src/cli/ArgumentHandler.hpp
Contents:
// ArgumentHandler.hpp
// Class that handles how command line arguments
// Are proccessed and then returned as a container of
// Options enum
#ifndef ARGUMENTHANDLER_H
#define ARGUMENTHANDLER_H

#include <forward_list>
#include <unordered_set>
#include <string>
#include <string_view>
#include <tuple>
#include "Option.hpp"
#include "OrderedUnique.hpp"
#include "../aliases_and_concepts/using.hpp"



class ArgumentHandler {
  public:
    explicit ArgumentHandler(int &argc, char **&argv); // Constructor
    ~ArgumentHandler() = default;                      // Destructor

    // public methods

    /*
        Returns the parsed arguments
    */
    parsed_pair get_parsed();

  private:
    // private_members
    raw_arguments raw_arguments_;
    parsed_options parsed_options_;
    parsed_targets parsed_targets_;
    // private methods

    /*
        Initializes raw_arguments
    */
    void init_raw_arguments_(int &argc, char **&argv);

	/*
		Check raw_arguments_ list
	*/
	bool check_raw_arguments_(raw_arguments& raw_arguments);

    /*
        Parses a single optional argument
    */
    void parse_option_(std::string_view& arg);

    /*
        Parses a single target (Non option argument)
    */
    void parse_target_(const std::string_view& arg);

    /*
        Parses all arguments into options and targets
    */
    parsed_pair parse_all_(raw_arguments& raw_arguments);

	/*
		Deduces a full option (e.g. --show-owner) when given an arg
	*/
	Option deduce_full_option_(const std::string_view& arg);

	/*
		Deduces an option (e.g. -O) when given char
	*/
	Option deduce_option_(const char c);

	/*
		Throw an exception to reduce copy&paste code
	*/
	[[noreturn]]
	void throw_invalid_argument_(const CharOrString auto& arg) {
		throw std::invalid_argument(std::format("Option '{}' not found\n", arg)); 
	}
};

#endif




Filename: csvls/src/cli/Option.hpp
Contents:
// Option.h
// An enum for parsing command line arguments
#ifndef OPTION_H
#define OPTION_H

enum class Option {
    ShowType,        // st_mode
    ShowPerms,       // st_mode
    ShowNLinks,      // st_nlink
    ShowOwner,       // st_uid
    ShowGroup,       // st_gid
    ShowSize,        // st_size
    ShowAccessTime,  // st_atime
    ShowModTime,     // st_mtime
    ShowMetaModTime, // st_ctime
    Name,            // (имя записи)
    Canonical,       // (канонический путь имени)
    ShowInode,       // st_ino
    ShowBlocks,      // st_blocks
    ShowDev,         // st_dev

    // other options
    Sort, // sort the list of options
	Help, // show help menu
	Recurcive // enable recursion when walking dirs
};

#endif



Filename: csvls/src/cli/OrderedUnique.hpp
Contents:
// OrderedUnique.hpp
// header-only class for storing arguments in order they were typed in
#ifndef ORDERED_UNIQUE_H
#define ORDERED_UNIQUE_H

#include <list>
#include <unordered_set>
#include <ranges>
#include "../aliases_and_concepts/concept.hpp"

template <Enum O> class OrderedUnique {
  public:
    OrderedUnique() = default;

	bool find(O&& option) {
		// auto it = std::ranges::find(lst_, option);
		// if (it != lst_.end()) return true;
		// else return false;
		auto it = set_.find(option);
		if (it != set_.end()) return true;
		else return false;
	}

    bool emplace_back(O&& option) {
        auto [it, inserted] = set_.insert(option);
        if (inserted) {
            lst_.emplace_back(option);
            return inserted;
        }
        return false;
    }

	std::list<O>& get_list() {return lst_;}
    auto begin() const { return lst_.begin(); }
    auto end() const { return lst_.end(); }

  private:
    std::unordered_set<O> set_{};
    std::list<O> lst_{};
};

#endif



Filename: csvls/src/checker/help.hpp
Contents:
// help.hpp
// print usage to stderr
#include <iostream>

constexpr void print_help() {
    std::cerr << "Usage:\n";
    std::cerr << "  program [options] <targets>...\n\n";
    std::cerr << "Description:\n";
    std::cerr << "  Targets are given without a leading \"-\" and must be existing directories to scan.\n\n";
    std::cerr << "Options:\n";
    std::cerr << "  -h, --help           Show this help message and exit."
	"\nIf -h is among other options, they will be ignored\n";
    std::cerr << "  -d, --show-dev       Display device ID.\n";
    std::cerr << "  -I, --show-inode     Display inode number.\n";
    std::cerr << "  -t, --show-type      Display file type.\n";
    std::cerr << "  -p, --show-perms     Display file permissions.\n";
    std::cerr << "  -n, --show-nlinks    Display number of hard links.\n";
    std::cerr << "  -O, --show-owner     Display owner’s user ID.\n";
    std::cerr << "  -g, --show-group     Display group ID.\n";
    std::cerr << "  -s, --show-size      Display size in bytes.\n";
    std::cerr << "  -b, --show-blocks    Display number of blocks.\n";
    std::cerr << "  -a, --show-access-time Display last access time.\n";
    std::cerr << "  -m, --show-mod-time  Display last modification time.\n";
    std::cerr << "  -M, --show-meta-mod-time Display metadata change time.\n";
    std::cerr << "  -N, --name           Display entry name.\n";
    std::cerr << "  -c, --canonical      Display canonical path.\n";
    std::cerr << "  -S, --sort           Sort output by selected options.\n";
    std::cerr << "  -r, --rec            Enable recursive directory traversal.\n";
}



Filename: csvls/src/checker/ArgumentProcessor.hpp
Contents:
// ArgumentProcessor.hpp
// A bundle of functions to check options and targets
#ifndef ARGUMENT_PROCESSOR_H
#define ARGUMENT_PROCESSOR_H

#include <iostream>
#include <filesystem>
#include <stdexcept>
#include <format>
#include <algorithm>
#include "help.hpp"
#include "../cli/Option.hpp"
#include "../aliases_and_concepts/using.hpp"
#include "../cli/ArgumentHandler.hpp"

namespace fs = std::filesystem;

namespace ArgumentProcessor {
	constexpr int check_target(const fs::path& target) {
		return fs::exists(target);
	}

	void check_targets(parsed_targets& targets) {
		auto it = targets.begin();
		auto end = targets.end();
		
		for( ; it != end ; ) {
			if (!check_target(*it)) {
				std::cerr << std::format("Target does not exist: {}\n", *it);
				it = targets.erase(it);
			} else {
				++it;
			}
		}

		if (targets.empty()) {
			throw std::invalid_argument("Targets that did not exist were erased, the set is empty\n");
		}
	}

	void check_targets_v2(parsed_targets& targets) {
	
		std::erase_if(
			targets,
			[&](auto const& t) {
				if (!check_target(t)) {
					std::cerr << std::format("Target does not exist: {}\n", t);
					return true;
				}
				return false;
			}
		);

		if (targets.empty()) {
			throw std::invalid_argument("Targets that did not exist were erased, the set is empty\n");
		}
	}

    void check_options(parsed_options &options) {

		//check if -h or --help
		if (options.find(Option::Help)) {
			print_help();
			throw std::invalid_argument("--h or --help is present");
		}

		// check wether name is present or not. If not then place it there
		const bool name_present = options.find(Option::Name);
		if (!name_present) {
			options.emplace_back(Option::Name);
		}
        // remove name if canonical is present
        if (name_present &&
            options.find(Option::Canonical)) {
            options.get_list().remove(Option::Name);
        }

        // sort & remove respective option
        if (options.find(Option::Sort)) {
            options.get_list().sort();
            options.get_list().remove(Option::Sort);
        }
    }
    } // namespace ArgumentProcessor

#endif



Filename: csvls/src/cli/build.sh
Contents:
#temporary build script
clang++ -Werror -Wall -c ArgumentHandler.cpp test.cpp -std=c++23
clang++ -Werror -Wall -o test test.o ArgumentHandler.o



